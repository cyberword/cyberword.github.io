<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Netty4源码解读 EventLoop篇 - A Coder</title><meta name=keywords content="JAVA,Netty"><meta name=description content="EventLoop是Netty Server用于处理IO事件的事件轮询处理器，职责上类似于Redis的eventLoop，EventLoop通常是由EventLoopGroup来管理的，EventLoopGroup负责调度指派EventLoop，而EventLoop负责具体的执行。
先看一下常用的NioEventLoopGroup结构关系图 继承关系： 方法图： 顺着关系图，先从各组件的基础功能说起。
EventExecutorGroup 自身提供shutdownGracefully执行器优雅关闭得接口
EventExecutorGroup接口继承ScheduleExecutorService和Iterable ScheduleExecutorService负责任务调度 Iterable负责返回next()的EventExecutor对象
EventExecutor EventExecutor继承EventExecutorGroup，在原有的接口基础上提供一些查看线程状态的接口
AbstractEventExecutorGroup AbstractEventExecutorGroup是基于EventExecutorGroup的抽象类，提供简单的任务调用，主要是一些通过next()获取Executor并执行任务的简单模板，如下
@Override public <T> Future<T> submit(Runnable task, T result) { return next().submit(task, result); } MultithreadEventExecutorGroup 继承AbstractEventExecutorGroup的简单抽象类，初始化children，该字段保存EventLoop数组。提供缺省的线程工厂和Executor，还有一些批量处理children的实现（比如shutdown）
需要特殊注意的是，创建的EventLoop的接口声明也是在这个抽象类中
protected abstract EventExecutor newChild(Executor executor, Object... args) throws Exception; 最终NioEventLoopGroup构造器都会进入下面的父类构造器
protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) {  nThread指定EventExecutor个数 executor指定执行器，默认使用ThreadPerTaskExecutor执行器，提供最基本的线程执行功能 chooserFactory生产EventExecutorChooser，chooser主要功能就是从executors列表中获取下一个EventExecutor（根据列表个数是否位2次幂选择PowerOfTwoEventExecutorChooser或GenericEventExecutorChooser），常用于next()方法用于获取下一个EventLoop args主要是提供构造Java Selector的SelectorProvider  MultithreadEventLoopGroup MultithreadEventLoopGroup继承MultithreadEventExecutorGroup接口，并实现EventLoopGroup接口，提供Channel注册相关的模板。
NioEventLoopGroup NioEventLoopGroup就是常见的Bootstrap(或ServerBootstrap)用于构造group()的实现类，其中实现了newChild接口用于创建具体的EventLoop实例。
@Override protected EventLoop newChild(Executor executor, Object... args) throws Exception { EventLoopTaskQueueFactory queueFactory = args."><meta name=author content="Me"><link rel=canonical href=https://cyberword.github.io/post/netty4-eventloop/><meta name=google-site-verification content="XYZabc"><link href=https://cyberword.github.io/assets/css/stylesheet.min.08d6f2005b6ce4ed10207916c0411c66e66f2201e3f7a56e8fb2ccbc4a8b259c.css integrity="sha256-CNbyAFts5O0QIHkWwEEcZuZvIgHj96Vuj7LMvEqLJZw=" rel="preload stylesheet" as=style><link rel=icon href=https://cyberword.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cyberword.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cyberword.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cyberword.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cyberword.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.78.2"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-123-45','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Netty4源码解读 EventLoop篇"><meta property="og:description" content="EventLoop是Netty Server用于处理IO事件的事件轮询处理器，职责上类似于Redis的eventLoop，EventLoop通常是由EventLoopGroup来管理的，EventLoopGroup负责调度指派EventLoop，而EventLoop负责具体的执行。
先看一下常用的NioEventLoopGroup结构关系图 继承关系： 方法图： 顺着关系图，先从各组件的基础功能说起。
EventExecutorGroup 自身提供shutdownGracefully执行器优雅关闭得接口
EventExecutorGroup接口继承ScheduleExecutorService和Iterable ScheduleExecutorService负责任务调度 Iterable负责返回next()的EventExecutor对象
EventExecutor EventExecutor继承EventExecutorGroup，在原有的接口基础上提供一些查看线程状态的接口
AbstractEventExecutorGroup AbstractEventExecutorGroup是基于EventExecutorGroup的抽象类，提供简单的任务调用，主要是一些通过next()获取Executor并执行任务的简单模板，如下
@Override public <T> Future<T> submit(Runnable task, T result) { return next().submit(task, result); } MultithreadEventExecutorGroup 继承AbstractEventExecutorGroup的简单抽象类，初始化children，该字段保存EventLoop数组。提供缺省的线程工厂和Executor，还有一些批量处理children的实现（比如shutdown）
需要特殊注意的是，创建的EventLoop的接口声明也是在这个抽象类中
protected abstract EventExecutor newChild(Executor executor, Object... args) throws Exception; 最终NioEventLoopGroup构造器都会进入下面的父类构造器
protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) {  nThread指定EventExecutor个数 executor指定执行器，默认使用ThreadPerTaskExecutor执行器，提供最基本的线程执行功能 chooserFactory生产EventExecutorChooser，chooser主要功能就是从executors列表中获取下一个EventExecutor（根据列表个数是否位2次幂选择PowerOfTwoEventExecutorChooser或GenericEventExecutorChooser），常用于next()方法用于获取下一个EventLoop args主要是提供构造Java Selector的SelectorProvider  MultithreadEventLoopGroup MultithreadEventLoopGroup继承MultithreadEventExecutorGroup接口，并实现EventLoopGroup接口，提供Channel注册相关的模板。
NioEventLoopGroup NioEventLoopGroup就是常见的Bootstrap(或ServerBootstrap)用于构造group()的实现类，其中实现了newChild接口用于创建具体的EventLoop实例。
@Override protected EventLoop newChild(Executor executor, Object... args) throws Exception { EventLoopTaskQueueFactory queueFactory = args."><meta property="og:type" content="article"><meta property="og:url" content="https://cyberword.github.io/post/netty4-eventloop/"><meta property="og:image" content="https://cyberword.github.io/%3Cimage%20path/url%3E"><meta property="article:published_time" content="2020-11-19T20:11:38+08:00"><meta property="article:modified_time" content="2020-11-19T20:11:38+08:00"><meta property="og:site_name" content="A Coder"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cyberword.github.io/%3Cimage%20path/url%3E"><meta name=twitter:title content="Netty4源码解读 EventLoop篇"><meta name=twitter:description content="EventLoop是Netty Server用于处理IO事件的事件轮询处理器，职责上类似于Redis的eventLoop，EventLoop通常是由EventLoopGroup来管理的，EventLoopGroup负责调度指派EventLoop，而EventLoop负责具体的执行。
先看一下常用的NioEventLoopGroup结构关系图 继承关系： 方法图： 顺着关系图，先从各组件的基础功能说起。
EventExecutorGroup 自身提供shutdownGracefully执行器优雅关闭得接口
EventExecutorGroup接口继承ScheduleExecutorService和Iterable ScheduleExecutorService负责任务调度 Iterable负责返回next()的EventExecutor对象
EventExecutor EventExecutor继承EventExecutorGroup，在原有的接口基础上提供一些查看线程状态的接口
AbstractEventExecutorGroup AbstractEventExecutorGroup是基于EventExecutorGroup的抽象类，提供简单的任务调用，主要是一些通过next()获取Executor并执行任务的简单模板，如下
@Override public <T> Future<T> submit(Runnable task, T result) { return next().submit(task, result); } MultithreadEventExecutorGroup 继承AbstractEventExecutorGroup的简单抽象类，初始化children，该字段保存EventLoop数组。提供缺省的线程工厂和Executor，还有一些批量处理children的实现（比如shutdown）
需要特殊注意的是，创建的EventLoop的接口声明也是在这个抽象类中
protected abstract EventExecutor newChild(Executor executor, Object... args) throws Exception; 最终NioEventLoopGroup构造器都会进入下面的父类构造器
protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) {  nThread指定EventExecutor个数 executor指定执行器，默认使用ThreadPerTaskExecutor执行器，提供最基本的线程执行功能 chooserFactory生产EventExecutorChooser，chooser主要功能就是从executors列表中获取下一个EventExecutor（根据列表个数是否位2次幂选择PowerOfTwoEventExecutorChooser或GenericEventExecutorChooser），常用于next()方法用于获取下一个EventLoop args主要是提供构造Java Selector的SelectorProvider  MultithreadEventLoopGroup MultithreadEventLoopGroup继承MultithreadEventExecutorGroup接口，并实现EventLoopGroup接口，提供Channel注册相关的模板。
NioEventLoopGroup NioEventLoopGroup就是常见的Bootstrap(或ServerBootstrap)用于构造group()的实现类，其中实现了newChild接口用于创建具体的EventLoop实例。
@Override protected EventLoop newChild(Executor executor, Object... args) throws Exception { EventLoopTaskQueueFactory queueFactory = args."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Netty4源码解读 EventLoop篇","name":"Netty4源码解读 EventLoop篇","description":"EventLoop是Netty Server用于处理IO事件的事件轮询处理器，职责上类似于Redis的eventLoop，EventLoop通常是由EventLoopGroup来管理的，EventLoopGroup负责调度指派EventLoop，而EventLoop负责具体的执行。\n先看一下常用的NioEventLoopGroup结构关系图 继承关系： 方法 …","keywords":["JAVA","Netty"],"articleBody":"EventLoop是Netty Server用于处理IO事件的事件轮询处理器，职责上类似于Redis的eventLoop，EventLoop通常是由EventLoopGroup来管理的，EventLoopGroup负责调度指派EventLoop，而EventLoop负责具体的执行。\n先看一下常用的NioEventLoopGroup结构关系图 继承关系： 方法图： 顺着关系图，先从各组件的基础功能说起。\nEventExecutorGroup 自身提供shutdownGracefully执行器优雅关闭得接口\nEventExecutorGroup接口继承ScheduleExecutorService和Iterable ScheduleExecutorService负责任务调度 Iterable负责返回next()的EventExecutor对象\nEventExecutor EventExecutor继承EventExecutorGroup，在原有的接口基础上提供一些查看线程状态的接口\nAbstractEventExecutorGroup AbstractEventExecutorGroup是基于EventExecutorGroup的抽象类，提供简单的任务调用，主要是一些通过next()获取Executor并执行任务的简单模板，如下\n@Override public T FutureT submit(Runnable task, T result) { return next().submit(task, result); } MultithreadEventExecutorGroup 继承AbstractEventExecutorGroup的简单抽象类，初始化children，该字段保存EventLoop数组。提供缺省的线程工厂和Executor，还有一些批量处理children的实现（比如shutdown）\n需要特殊注意的是，创建的EventLoop的接口声明也是在这个抽象类中\nprotected abstract EventExecutor newChild(Executor executor, Object... args) throws Exception; 最终NioEventLoopGroup构造器都会进入下面的父类构造器\nprotected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) {  nThread指定EventExecutor个数 executor指定执行器，默认使用ThreadPerTaskExecutor执行器，提供最基本的线程执行功能 chooserFactory生产EventExecutorChooser，chooser主要功能就是从executors列表中获取下一个EventExecutor（根据列表个数是否位2次幂选择PowerOfTwoEventExecutorChooser或GenericEventExecutorChooser），常用于next()方法用于获取下一个EventLoop args主要是提供构造Java Selector的SelectorProvider  MultithreadEventLoopGroup MultithreadEventLoopGroup继承MultithreadEventExecutorGroup接口，并实现EventLoopGroup接口，提供Channel注册相关的模板。\nNioEventLoopGroup NioEventLoopGroup就是常见的Bootstrap(或ServerBootstrap)用于构造group()的实现类，其中实现了newChild接口用于创建具体的EventLoop实例。\n@Override protected EventLoop newChild(Executor executor, Object... args) throws Exception { EventLoopTaskQueueFactory queueFactory = args.length == 4 ? (EventLoopTaskQueueFactory) args[3] : null; return new NioEventLoop(this, executor, (SelectorProvider) args[0], ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2], queueFactory); } NioEventLoop 最常见的Netty EventLoop实现类，先看下NioEventLoop关系图 看起来很复杂，别慌下面会对几个组件大致说明一下，先看几个基础的抽象类\nAbstractExecutorService 首先看AbstractExecutorService抽象类，熟悉JUC线程池工具包的应该比较眼熟，常用的用于构造线程池的ThreadPoolExecutor对象就是继承自它，netty并没有沿用JUC的线程池而是选择自己实现，AbstractExecutorService类只是提供基础的task创建，submit和invoke等操作的基础实现。\nAbstractEventExecutor AbstractEventExecutor继承AbstractExecutorService和EventExecutor接口，是个抽象基类，东西不多这里略过。\nAbstractScheduledEventExecutor AbstractScheduledEventExecutor有些类似JUC的ScheduledThreadPoolExecutor，主要是任务调度的模板。\nSingleThreadEventExecutor 和SingleThreadEventLoop SingleThreadEventExecutor，任务调度的基本实现都在这个类里，execute具体实现也在当中。 SingleThreadEventLoop继承SingleThreadEventExecutor，实现了部分注册Channel和执行全部已提交任务的模板。\nNioEventLoop 接下来终于轮到NioEventLoop了，主要负责Nio轮询逻辑。\n首先如上所述NioEventLoop是在构建NioEventLoopGroup时由其父类MultithreadEventExecutorGroup在构造器中初始EventExecutor数组（children）时调用newChild创建的。\n下面是NioEventLoop的构造器，内有注释\nNioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) { //newTaskQueue创建队列（jctools) \tsuper(parent, executor, false, newTaskQueue(queueFactory), newTaskQueue(queueFactory), rejectedExecutionHandler); //设置nio selectorProvider \tthis.provider = ObjectUtil.checkNotNull(selectorProvider, \"selectorProvider\"); //设置select策略选择器，负责控制nio loop逻辑 \tthis.selectStrategy = ObjectUtil.checkNotNull(strategy, \"selectStrategy\"); //selectorTuple其实就是一个简单的bean，内部存有原生selector和包装后的selector \tfinal SelectorTuple selectorTuple = openSelector(); this.selector = selectorTuple.selector; this.unwrappedSelector = selectorTuple.unwrappedSelector; } taskQueue任务队列也是在这个时候创建的，默认使用的是JCTools的MPSC队列，是一个多生产单消费的高性能队列。\n任务的调度 上面主要是梳理了一下NioEventLoopGroup的继承关系，下面会详细分析netty是如何设计事件模型来进行IO任务调度。\n为了更好的梳理流程，我们不妨从一个简单的netty服务端demo出发 下面是一个netty官方提供的EchoServer\npublic final class EchoServer { static final boolean SSL = System.getProperty(\"ssl\") != null; static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\")); public static void main(String[] args) throws Exception { // Configure SSL.  final SslContext sslCtx; if (SSL) { SelfSignedCertificate ssc = new SelfSignedCertificate(); sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build(); } else { sslCtx = null; } // Configure the server.  EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); final EchoServerHandler serverHandler = new EchoServerHandler(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializerSocketChannel() { @Override public void initChannel(SocketChannel ch) { ChannelPipeline p = ch.pipeline(); if (sslCtx != null) { p.addLast(sslCtx.newHandler(ch.alloc())); } //p.addLast(new LoggingHandler(LogLevel.INFO));  p.addLast(serverHandler); } }); // Start the server.  ChannelFuture f = b.bind(PORT).sync(); // Wait until the server socket is closed.  f.channel().closeFuture().sync(); } finally { // Shut down all event loops to terminate all threads.  bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } } 忽略掉ssl部分，首先构建了两个EventLoopGroup实例，在这过程中发生了什么前面已经说过了，然后是设置channel和handler以及childHandler，最终调用bind()，下面会解释netty内部都做了些什么。\nAbstractBootstrap 上面的例子执行bind()方法后，最后进入到AbstractBootstrap.doBind()方法中\nprivate ChannelFuture doBind(final SocketAddress localAddress) { final ChannelFuture regFuture = initAndRegister(); final Channel channel = regFuture.channel(); if (regFuture.cause() != null) { return regFuture; } //忽略掉一些细节，最主要的就是执行下面的一段代码  ChannelPromise promise = channel.newPromise(); doBind0(regFuture, channel, localAddress, promise); return promise; } } initAndRegister initAndRegister()负责创建和初始化channel，并返回ChannelFuture对象用于后续添加监听器来异步的处理后续的任务。 initAndRegister是初始化流程中非常重要的一步，channel的构建，注册, eventLoop线程启动都是在这之中，下面会依次注明netty是如何初始化这几个对象，一些重要的说明会在代码中注释\nfinal ChannelFuture initAndRegister() { Channel channel = null; try { //构造netty的channel实例，也是这个时候和java nio中的原生channel做绑定  channel = channelFactory.newChannel(); //初始化channel，server端和客户端的初始逻辑不同，server端会为pipelinee额外添加名为ServerBootstrapAcceptor的handler，而客户端只会添加初始化时用户指定的handler  init(channel); } catch (Throwable t) { if (channel != null) { // channel can be null if newChannel crashed (eg SocketException(\"too many open files\"))  channel.unsafe().closeForcibly(); // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor  return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t); } // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor  return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t); } //为channel执行register注册逻辑，主要完成nio中channel的register操作，nio的selector在eventloop初始化时就已经创建好了  ChannelFuture regFuture = config().group().register(channel); if (regFuture.cause() != null) { if (channel.isRegistered()) { channel.close(); } else { channel.unsafe().closeForcibly(); } } return regFuture; }  init(channel) 初始化channel，server端和客户端的初始逻辑不同，server端会为pipeline额外添加名为ServerBootstrapAcceptor的handler，而客户端只会添加初始化时用户指定的handler. config().group().register(channel) 为channel执行register注册逻辑，主要完成nio中channel的register操作, selector在eventloop初始化时就已经创建好了。  而eventloop轮询线程的启动也是在调用register()时触发的。 首先调用MultithreadEventLoopGroup.register()\npublic ChannelFuture register(Channel channel) { return next().register(channel); } next()就是从children中获取下一个eventloop, 获取具体的eventloop实例后首先通过SingleThreadEventLoop抽象类把channel包装成ChannelPromise(channelFuture接口的可写模式)并获取unsafe()来完成底层的register功能\npublic ChannelFuture register(final ChannelPromise promise) { ObjectUtil.checkNotNull(promise, \"promise\"); promise.channel().unsafe().register(this, promise); return promise; } public ChannelFuture register(final Channel channel, final ChannelPromise promise) { ObjectUtil.checkNotNull(promise, \"promise\"); ObjectUtil.checkNotNull(channel, \"channel\"); channel.unsafe().register(this, promise); return promise; } 最后由AbstractChannel抽象类的内部类AbstractUnsafe来完成底层的register操作\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) { ObjectUtil.checkNotNull(eventLoop, \"eventLoop\"); //已注册直接返回，future标记错误  if (isRegistered()) { promise.setFailure(new IllegalStateException(\"registered to an event loop already\")); return; } //校验是否兼容  if (!isCompatible(eventLoop)) { promise.setFailure( new IllegalStateException(\"incompatible event loop type: \" + eventLoop.getClass().getName())); return; } //为channel绑定eventLoop  AbstractChannel.this.eventLoop = eventLoop; //检查当前线程是否为ecentLoo绑定线程，绑定线程是在启动ecentloop时设置的  if (eventLoop.inEventLoop()) { //调用实际绑定方法  register0(promise); } else { try { //调用execure来执行refister0()实际注册逻辑  eventLoop.execute(new Runnable() { @Override public void run() { register0(promise); } }); } catch (Throwable t) { logger.warn( \"Force-closing a channel whose registration task was not accepted by an event loop: {}\", AbstractChannel.this, t); closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); } } } 经过一些校验后，通过register0()中的**doRegister()**来完成实际注册操作\nprivate void register0(ChannelPromise promise) { try { // check if the channel is still open as it could be closed in the mean time when the register  // call was outside of the eventLoop  if (!promise.setUncancellable() || !ensureOpen(promise)) { return; } boolean firstRegistration = neverRegistered; doRegister();//完成channel的注册  neverRegistered = false; registered = true;//标记为已注册  ... pipeline部分逻辑省略 } doRegister()的实现则在AbstractNioChannel抽象类中\nprotected void doRegister() throws Exception { boolean selected = false; for (;;) { try { selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this); return; } catch (CancelledKeyException e) { ... } } 到这里netty才完成实际的java NioChannel的注册逻辑。\nEventLoop线程 上面讲到了如何为channel实现register绑定操作，那么回到正题EventLoop的轮询调度线程是何时被启动的呢？其实就是在刚才AbstractChannel调用register时启动的。\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) { ... if (eventLoop.inEventLoop()) { register0(promise); } else { try { eventLoop.execute(new Runnable() { @Override public void run() { register0(promise); } }); } catch (Throwable t) { ... } } } register会调用eventLoop的execute方法来执行register0，现在来看一下execute做了些什么。首先会进入到SingleThreadEventExecutor.execute\nprivate void execute(Runnable task, boolean immediate) { //inEventLoop判断当前线程是否与SingleThreadEventExecutor.thread相同，thread是在启动loop线程时设置的，所以为启动前为null  boolean inEventLoop = inEventLoop(); //添加任务至队列  addTask(task); if (!inEventLoop) { //启动eventLoop线程  startThread(); if (isShutdown()) { boolean reject = false; try { if (removeTask(task)) { reject = true; } } catch (UnsupportedOperationException e) {1 } if (reject) { reject(); } } } if (!addTaskWakesUp \u0026\u0026 immediate) { wakeup(inEventLoop); } } inEventLoop判断当前线程是否与SingleThreadEventExecutor.thread相同，thread是在启动loop线程时设置的，所以未启动前为null。\nSingleThreadEventExecutor先将要执行的任务添加至队列，上文提到的register任务也会添加至该队列，队列初始则是由上文提到的NioEventLoop构造器来完成的。\nstartThread方法主要是对状态字段state作CAS检查并执行doStartThread()\nprivate void startThread() { if (state == ST_NOT_STARTED) { if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) { boolean success = false; try { doStartThread(); success = true; } finally { if (!success) { STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_NOT_STARTED); } } } } } doStartThread通过executor来执行真正负责轮询逻辑的**SingleThreadEventExecutor.this.run()**方法, 另外executor可以通过NioEventLoopGroup构造器指定, 默认使用ThreadPerTaskExecutor每一次执行任务创建一个新线程执行任务。\nprivate void doStartThread() { assert thread == null; executor.execute(new Runnable() { @Override public void run() { thread = Thread.currentThread(); //检查是否中断  if (interrupted) { thread.interrupt(); } boolean success = false; //更新时间单位为纳秒  updateLastExecutionTime(); try { //执行具体的轮询任务，该方法为抽象方法  SingleThreadEventExecutor.this.run(); success = true; } catch (Throwable t) { logger.warn(\"Unexpected exception from an event executor: \", t); } finally { //省略掉了shutdown后续确认逻辑，感兴趣的可以看一下源码  } } }); } SingleThreadEventExecutor.this.run()是抽象方法，而在netty中 实现类默认为NioEventLoop（NioEventLoop由NioEventLoopGroup确定，支持epoll的linux中用户也可以通过指定EpollEventLoopGroup来获取EpollEventLoop，java nio其实已经支持epoll操作，不过相比nio来说EpollEventLoop性能更好些，因为采用ET模式，同时更少的gc, 因为执行run的大致逻辑相同，这里就基于常用的NioEventLoop来说明）\nrun主要执行以下步骤：\n 检查当前是否有任务，如果有通过supplier非阻塞调用select获取事件个数(selectNow方法，即select超时时间设置0)，否则返回SelectStrategy.SELECT枚举表示进行阻塞select 获取scheduleTask定时任务堆顶任务的deadline时间，如果枚举为SELECT则先通过deadline计算timeout并select阻塞。 获取ioRatio参数，该值决定一次轮询处理任务的 预计最大时间 = io等待时间 * （100 - ratio）/ratio，假设ratio为50则处理任务最大耗时为io时间相同，默认设置为50. 调用processSelectedKeys处理selectKeys，通过ioRatio获得处理任务最大时间并执行任务。  下面是源码附注释：\nprotected void run() { //计数器记录select次数  int selectCnt = 0; for (;;) { try { int strategy; try {//当前有任务通过supplier非阻塞调用select获取事件个数，否则返回SelectStrategy.SELECT枚举表示进行阻塞select  strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks()); switch (strategy) { case SelectStrategy.CONTINUE: continue; case SelectStrategy.BUSY_WAIT: // fall-through to SELECT since the busy-wait is not supported with NIO  case SelectStrategy.SELECT: //获取schedule定时任务的deadline  long curDeadlineNanos = nextScheduledTaskDeadlineNanos(); if (curDeadlineNanos == -1L) { curDeadlineNanos = NONE; // nothing on the calendar  } nextWakeupNanos.set(curDeadlineNanos); try { if (!hasTasks()) { strategy = select(curDeadlineNanos); } } finally { // This update is just to help block unnecessary selector wakeups  // so use of lazySet is ok (no race condition)  nextWakeupNanos.lazySet(AWAKE); } // fall through  default: } } catch (IOException e) { // If we receive an IOException here its because the Selector is messed up. Let's rebuild  // the selector and retry. https://github.com/netty/netty/issues/8566  rebuildSelector0(); selectCnt = 0; handleLoopException(e); continue; } selectCnt++; cancelledKeys = 0; needsToSelectAgain = false; //ioRatio默认为50  final int ioRatio = this.ioRatio; boolean ranTasks; //100一次性执行全部任务  if (ioRatio == 100) { try { if (strategy  0) { processSelectedKeys(); } } finally { // Ensure we always run tasks.  ranTasks = runAllTasks(); } } else if (strategy  0) { final long ioStartTime = System.nanoTime(); try { //处理selectKey  processSelectedKeys(); } finally { // Ensure we always run tasks.  final long ioTime = System.nanoTime() - ioStartTime; //根据ioRatio设置任务的处理时间  ranTasks = runAllTasks(ioTime * (100 - ioRatio) / ioRatio); } } else { ranTasks = runAllTasks(0); // This will run the minimum number of tasks  } if (ranTasks || strategy  0) { if (selectCnt  MIN_PREMATURE_SELECTOR_RETURNS \u0026\u0026 logger.isDebugEnabled()) { logger.debug(\"Selector.select() returned prematurely {} times in a row for Selector {}.\", selectCnt - 1, selector); } selectCnt = 0; } else if (unexpectedSelectorWakeup(selectCnt)) { // Unexpected wakeup (unusual case)  selectCnt = 0; } } catch (CancelledKeyException e) { // Harmless exception - log anyway  if (logger.isDebugEnabled()) { logger.debug(CancelledKeyException.class.getSimpleName() + \" raised by a Selector {} - JDK bug?\", selector, e); } } catch (Throwable t) { handleLoopException(t); } // Always handle shutdown even if the loop processing threw an exception.  try { if (isShuttingDown()) { closeAll(); if (confirmShutdown()) { return; } } } catch (Throwable t) { handleLoopException(t); } } } 关于轮询逻辑还有两个比较重要的点：\n 这里处理任务最大时间是预估时间，原理是串行处理任务时刷新并比对deadline时间，可想而知如果任务是阻塞的就会严重影响nioEventLoop的性能，因此要求用户不要执行阻塞的任务。 细心的可能注意到有一个计数变量selectCnt用来表示select次数，在末尾处会调用unexpectedSelectorWakeup方法校验selectCnt数值是否超出阈值（默认512),如果超出阈值则调用rebuildSelector重新创建新的selector，并把旧的selector已注册的channel重新加入到新的selector中.  private boolean unexpectedSelectorWakeup(int selectCnt) { ...省略部分代码 //检查selectCnt是否超出阈值，如果超出阈值则调用rebuildSelector重新创建新的selector，并把旧的selector已注册的channel重新加入到新的selector中  if (SELECTOR_AUTO_REBUILD_THRESHOLD  0 \u0026\u0026 selectCnt = SELECTOR_AUTO_REBUILD_THRESHOLD) { // The selector returned prematurely many times in a row.  // Rebuild the selector to work around the problem.  logger.warn(\"Selector.select() returned prematurely {} times in a row; rebuilding Selector {}.\", selectCnt, selector); rebuildSelector(); return true; } return false; } 为什么超出阈值就要重新构造selector呢，这来源于jdk nio一个有名的epoll cpu 100%的bug，jdk-bug-6403933，该bug使select不能正常阻塞，因用户nio线程空转导致cpu飙升，所以netty使用计数的方式来检测该问题，并重新构建selector。\nworker、boss的分工 BootStrap初始化的时候会要求设置worker和boss，例如EchoServer例子中的bossGroup和workerGroup，一般介绍中都会说到boss负责accpet，worker负责IO事件如下图，下面来解析netty如何调度流转worker和boss 首先Java NIO server需要指定ServerSocketChannel来完成bind、accept等操作，而netty则是对NIO的封装，那么ServerSocketChannel是在何时构造的呢，是在调用initAndRegister是，initAndRegister时会调用channelFactory.newChannel()\nfinal ChannelFuture initAndRegister() { Channel channel = null; try { channel = channelFactory.newChannel(); init(channel); } .... } channelFactory需要指定class来实例化channel，这个channel即使在构造BootStrap时声明的，如下实例声明的NioServerSocketChannel.class\nServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) 之后就执行BossGroup下的EventLoop轮询逻辑，到目前为止其实与Worker还没有关系，先看一下如果用户声明的是ServerBootstrap，那么在调用initAndRegester时会调用init()，init又一个重要操作就是通过匿名函数将ServerBootstrapAcceptor加入到链表尾部。\nvoid init(Channel channel) { //设置参数  setChannelOptions(channel, newOptionsArray(), logger); setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY)); //获取pipelone  ChannelPipeline p = channel.pipeline(); final EventLoopGroup currentChildGroup = childGroup; final ChannelHandler currentChildHandler = childHandler; final EntryChannelOption, Object[] currentChildOptions; synchronized (childOptions) { currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY); } final EntryAttributeKey, Object[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY); //将handler添加至尾部  p.addLast(new ChannelInitializerChannel() { @Override public void initChannel(final Channel ch) { final ChannelPipeline pipeline = ch.pipeline(); ChannelHandler handler = config.handler(); if (handler != null) { pipeline.addLast(handler); } ch.eventLoop().execute(new Runnable() { @Override public void run() { pipeline.addLast(new ServerBootstrapAcceptor( ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)); } }); } }); } ServerBootstrapAcceptor是InboundHandler类型，会把BossGroup下的Eventloop监听到的Channel事件注册到childGroup(即worker)下，代码如下\npublic void channelRead(ChannelHandlerContext ctx, Object msg) { final Channel child = (Channel) msg; //将childHandler加入链表  child.pipeline().addLast(childHandler); setChannelOptions(child, childOptions, logger); setAttributes(child, childAttrs); try { //将channel注册至childGroup，即workerGroup下  childGroup.register(child).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (!future.isSuccess()) { forceClose(child, future.cause()); } } }); } catch (Throwable t) { //出现异常关闭channel  forceClose(child, t); } } 到此就完成了boss和worker之间的流转，至于channel是如何流转，pipeline原理等其他内容就放到Channel篇来讲述。\n","wordCount":"1507","inLanguage":"en","image":"https://cyberword.github.io/%3Cimage%20path/url%3E","datePublished":"2020-11-19T20:11:38+08:00","dateModified":"2020-11-19T20:11:38+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cyberword.github.io/post/netty4-eventloop/"},"publisher":{"@type":"Organization","name":"A Coder","logo":{"@type":"ImageObject","url":"https://cyberword.github.io/favicon.ico"}}}</script></head><body class=single id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://cyberword.github.io/ accesskey=h><img src=/apple-touch-icon.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://cyberword.github.io/tags/><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Netty4源码解读 EventLoop篇</h1><div class=post-meta>November 19, 2020&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</div></header><figure class=entry-cover><img src=https://cyberword.github.io/%3Cimage%20path/url%3E alt><p></p></figure><div class=toc><details><summary><div class=details accesskey=c>Table of Contents</div></summary><blockquote><ul><ul><li><a href=#eventexecutorgroup aria-label=EventExecutorGroup>EventExecutorGroup</a><ul><li><a href=#eventexecutor aria-label=EventExecutor>EventExecutor</a></li></ul></li><li><a href=#abstracteventexecutorgroup aria-label=AbstractEventExecutorGroup>AbstractEventExecutorGroup</a></li><li><a href=#multithreadeventexecutorgroup aria-label=MultithreadEventExecutorGroup>MultithreadEventExecutorGroup</a></li><li><a href=#multithreadeventloopgroup aria-label=MultithreadEventLoopGroup>MultithreadEventLoopGroup</a></li><li><a href=#nioeventloopgroup aria-label=NioEventLoopGroup>NioEventLoopGroup</a></li><li><a href=#nioeventloop aria-label=NioEventLoop>NioEventLoop</a><ul><li><a href=#abstractexecutorservice aria-label=AbstractExecutorService>AbstractExecutorService</a></li><li><a href=#abstracteventexecutor aria-label=AbstractEventExecutor>AbstractEventExecutor</a></li><li><a href=#abstractscheduledeventexecutor aria-label=AbstractScheduledEventExecutor>AbstractScheduledEventExecutor</a></li></ul></li><li><a href=#singlethreadeventexecutor-%e5%92%8csinglethreadeventloop aria-label="SingleThreadEventExecutor 和SingleThreadEventLoop">SingleThreadEventExecutor 和SingleThreadEventLoop</a></li><li><a href=#nioeventloop-1 aria-label=NioEventLoop>NioEventLoop</a></li><li><a href=#%e4%bb%bb%e5%8a%a1%e7%9a%84%e8%b0%83%e5%ba%a6 aria-label=任务的调度>任务的调度</a></li><li><a href=#abstractbootstrap aria-label=AbstractBootstrap>AbstractBootstrap</a></li><li><a href=#initandregister aria-label=initAndRegister>initAndRegister</a></li></ul><li><a href=#eventloop%e7%ba%bf%e7%a8%8b aria-label=EventLoop线程>EventLoop线程</a></li><li><a href=#workerboss%e7%9a%84%e5%88%86%e5%b7%a5 aria-label=worker、boss的分工>worker、boss的分工</a></li></ul></blockquote></details></div><div class=post-content><p><img src=/img/bVcKiG3 alt=image.png></p><p><strong>EventLoop</strong>是Netty Server用于处理IO事件的事件轮询处理器，职责上类似于Redis的eventLoop，EventLoop通常是由EventLoopGroup来管理的，EventLoopGroup负责调度指派EventLoop，而EventLoop负责具体的执行。</p><p>先看一下常用的<strong>NioEventLoopGroup</strong>结构关系图
继承关系：
<img src=/img/bVcKsjT alt=image.png>
方法图：
<img src=/img/bVcKskX alt=image.png></p><p>顺着关系图，先从各组件的基础功能说起。</p><h4 id=eventexecutorgroup>EventExecutorGroup<a hidden class=anchor aria-hidden=true href=#eventexecutorgroup>#</a></h4><p>自身提供shutdownGracefully执行器优雅关闭得接口</p><p>EventExecutorGroup接口继承ScheduleExecutorService和Iterable
ScheduleExecutorService负责任务调度
Iterable负责返回next()的EventExecutor对象</p><h5 id=eventexecutor>EventExecutor<a hidden class=anchor aria-hidden=true href=#eventexecutor>#</a></h5><p>EventExecutor继承EventExecutorGroup，在原有的接口基础上提供一些查看线程状态的接口</p><h4 id=abstracteventexecutorgroup>AbstractEventExecutorGroup<a hidden class=anchor aria-hidden=true href=#abstracteventexecutorgroup>#</a></h4><p>AbstractEventExecutorGroup是基于EventExecutorGroup的抽象类，提供简单的任务调用，主要是一些通过next()获取Executor并执行任务的简单模板，如下</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Override</span>
<span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>submit</span><span style=color:#f92672>(</span>Runnable task<span style=color:#f92672>,</span> T result<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> next<span style=color:#f92672>().</span><span style=color:#a6e22e>submit</span><span style=color:#f92672>(</span>task<span style=color:#f92672>,</span> result<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div><h4 id=multithreadeventexecutorgroup>MultithreadEventExecutorGroup<a hidden class=anchor aria-hidden=true href=#multithreadeventexecutorgroup>#</a></h4><p>继承AbstractEventExecutorGroup的简单抽象类，初始化<strong>children</strong>，该字段保存EventLoop数组。提供缺省的线程工厂和Executor，还有一些批量处理children的实现（比如shutdown）</p><p>需要特殊注意的是，创建的EventLoop的接口声明也是在这个抽象类中</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>abstract</span> EventExecutor <span style=color:#a6e22e>newChild</span><span style=color:#f92672>(</span>Executor executor<span style=color:#f92672>,</span> Object<span style=color:#f92672>...</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception<span style=color:#f92672>;</span>
</code></pre></div><p>最终NioEventLoopGroup构造器都会进入下面的父类构造器</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>MultithreadEventExecutorGroup</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> nThreads<span style=color:#f92672>,</span> Executor executor<span style=color:#f92672>,</span>
 EventExecutorChooserFactory chooserFactory<span style=color:#f92672>,</span> Object<span style=color:#f92672>...</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</code></pre></div><ul><li>nThread指定EventExecutor个数</li><li>executor指定执行器，默认使用ThreadPerTaskExecutor执行器，提供最基本的线程执行功能</li><li>chooserFactory生产EventExecutorChooser，chooser主要功能就是从executors列表中获取下一个EventExecutor（根据列表个数是否位2次幂选择PowerOfTwoEventExecutorChooser或GenericEventExecutorChooser），常用于next()方法用于获取下一个EventLoop</li><li>args主要是提供构造Java Selector的SelectorProvider</li></ul><h4 id=multithreadeventloopgroup>MultithreadEventLoopGroup<a hidden class=anchor aria-hidden=true href=#multithreadeventloopgroup>#</a></h4><p>MultithreadEventLoopGroup继承MultithreadEventExecutorGroup接口，并实现EventLoopGroup接口，提供Channel注册相关的模板。</p><h4 id=nioeventloopgroup>NioEventLoopGroup<a hidden class=anchor aria-hidden=true href=#nioeventloopgroup>#</a></h4><p>NioEventLoopGroup就是常见的Bootstrap(或ServerBootstrap)用于构造group()的实现类，其中实现了newChild接口用于创建具体的EventLoop实例。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>protected</span> EventLoop <span style=color:#a6e22e>newChild</span><span style=color:#f92672>(</span>Executor executor<span style=color:#f92672>,</span> Object<span style=color:#f92672>...</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
        EventLoopTaskQueueFactory queueFactory <span style=color:#f92672>=</span> args<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> 4 <span style=color:#f92672>?</span> <span style=color:#f92672>(</span>EventLoopTaskQueueFactory<span style=color:#f92672>)</span> args<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> NioEventLoop<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> executor<span style=color:#f92672>,</span> <span style=color:#f92672>(</span>SelectorProvider<span style=color:#f92672>)</span> args<span style=color:#f92672>[</span>0<span style=color:#f92672>],</span>
            <span style=color:#f92672>((</span>SelectStrategyFactory<span style=color:#f92672>)</span> args<span style=color:#f92672>[</span>1<span style=color:#f92672>]).</span><span style=color:#a6e22e>newSelectStrategy</span><span style=color:#f92672>(),</span> <span style=color:#f92672>(</span>RejectedExecutionHandler<span style=color:#f92672>)</span> args<span style=color:#f92672>[</span>2<span style=color:#f92672>],</span> queueFactory<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
</code></pre></div><h4 id=nioeventloop>NioEventLoop<a hidden class=anchor aria-hidden=true href=#nioeventloop>#</a></h4><p>最常见的Netty EventLoop实现类，先看下NioEventLoop关系图
<img src=/img/bVcKsmM alt=image.png></p><p>看起来很复杂，别慌下面会对几个组件大致说明一下，先看几个基础的抽象类</p><h5 id=abstractexecutorservice>AbstractExecutorService<a hidden class=anchor aria-hidden=true href=#abstractexecutorservice>#</a></h5><p>首先看AbstractExecutorService抽象类，熟悉JUC线程池工具包的应该比较眼熟，常用的用于构造线程池的ThreadPoolExecutor对象就是继承自它，netty并没有沿用JUC的线程池而是选择自己实现，AbstractExecutorService类只是提供基础的task创建，submit和invoke等操作的基础实现。</p><h5 id=abstracteventexecutor>AbstractEventExecutor<a hidden class=anchor aria-hidden=true href=#abstracteventexecutor>#</a></h5><p>AbstractEventExecutor继承AbstractExecutorService和EventExecutor接口，是个抽象基类，东西不多这里略过。</p><h5 id=abstractscheduledeventexecutor>AbstractScheduledEventExecutor<a hidden class=anchor aria-hidden=true href=#abstractscheduledeventexecutor>#</a></h5><p>AbstractScheduledEventExecutor有些类似JUC的ScheduledThreadPoolExecutor，主要是任务调度的模板。</p><h4 id=singlethreadeventexecutor-和singlethreadeventloop>SingleThreadEventExecutor 和SingleThreadEventLoop<a hidden class=anchor aria-hidden=true href=#singlethreadeventexecutor-和singlethreadeventloop>#</a></h4><p>SingleThreadEventExecutor，任务调度的基本实现都在这个类里，execute具体实现也在当中。
SingleThreadEventLoop继承SingleThreadEventExecutor，实现了部分注册Channel和执行全部已提交任务的模板。</p><h4 id=nioeventloop-1>NioEventLoop<a hidden class=anchor aria-hidden=true href=#nioeventloop-1>#</a></h4><p>接下来终于轮到NioEventLoop了，主要负责Nio轮询逻辑。</p><p>首先如上所述NioEventLoop是在构建NioEventLoopGroup时由其父类<strong>MultithreadEventExecutorGroup</strong>在构造器中初始EventExecutor数组（children）时调用newChild创建的。</p><p>下面是NioEventLoop的构造器，内有注释</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>NioEventLoop<span style=color:#f92672>(</span>NioEventLoopGroup parent<span style=color:#f92672>,</span> Executor executor<span style=color:#f92672>,</span> SelectorProvider selectorProvider<span style=color:#f92672>,</span>
			 SelectStrategy strategy<span style=color:#f92672>,</span> RejectedExecutionHandler rejectedExecutionHandler<span style=color:#f92672>,</span>
			 EventLoopTaskQueueFactory queueFactory<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
	<span style=color:#75715e>//newTaskQueue创建队列（jctools)
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>parent<span style=color:#f92672>,</span> executor<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>,</span> newTaskQueue<span style=color:#f92672>(</span>queueFactory<span style=color:#f92672>),</span> newTaskQueue<span style=color:#f92672>(</span>queueFactory<span style=color:#f92672>),</span>
			rejectedExecutionHandler<span style=color:#f92672>);</span>
    <span style=color:#75715e>//设置nio selectorProvider
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>provider</span> <span style=color:#f92672>=</span> ObjectUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>checkNotNull</span><span style=color:#f92672>(</span>selectorProvider<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;selectorProvider&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#75715e>//设置select策略选择器，负责控制nio loop逻辑
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>selectStrategy</span> <span style=color:#f92672>=</span> ObjectUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>checkNotNull</span><span style=color:#f92672>(</span>strategy<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;selectStrategy&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#75715e>//selectorTuple其实就是一个简单的bean，内部存有原生selector和包装后的selector
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>final</span> SelectorTuple selectorTuple <span style=color:#f92672>=</span> openSelector<span style=color:#f92672>();</span>
	<span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>selector</span> <span style=color:#f92672>=</span> selectorTuple<span style=color:#f92672>.</span><span style=color:#a6e22e>selector</span><span style=color:#f92672>;</span>
	<span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>unwrappedSelector</span> <span style=color:#f92672>=</span> selectorTuple<span style=color:#f92672>.</span><span style=color:#a6e22e>unwrappedSelector</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>

</code></pre></div><p>taskQueue任务队列也是在这个时候创建的，默认使用的是JCTools的MPSC队列，是一个多生产单消费的高性能队列。</p><h4 id=任务的调度>任务的调度<a hidden class=anchor aria-hidden=true href=#任务的调度>#</a></h4><p>上面主要是梳理了一下NioEventLoopGroup的继承关系，下面会详细分析netty是如何设计事件模型来进行IO任务调度。</p><p>为了更好的梳理流程，我们不妨从一个简单的netty服务端demo出发
下面是一个netty官方提供的EchoServer</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EchoServer</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> SSL <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>getProperty</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;ssl&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> PORT <span style=color:#f92672>=</span> Integer<span style=color:#f92672>.</span><span style=color:#a6e22e>parseInt</span><span style=color:#f92672>(</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>getProperty</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;port&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;8007&#34;</span><span style=color:#f92672>));</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
        <span style=color:#75715e>// Configure SSL.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>final</span> SslContext sslCtx<span style=color:#f92672>;</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>SSL<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            SelfSignedCertificate ssc <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SelfSignedCertificate<span style=color:#f92672>();</span>
            sslCtx <span style=color:#f92672>=</span> SslContextBuilder<span style=color:#f92672>.</span><span style=color:#a6e22e>forServer</span><span style=color:#f92672>(</span>ssc<span style=color:#f92672>.</span><span style=color:#a6e22e>certificate</span><span style=color:#f92672>(),</span> ssc<span style=color:#f92672>.</span><span style=color:#a6e22e>privateKey</span><span style=color:#f92672>()).</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
            sslCtx <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>

        <span style=color:#75715e>// Configure the server.
</span><span style=color:#75715e></span>        EventLoopGroup bossGroup <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NioEventLoopGroup<span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
        EventLoopGroup workerGroup <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NioEventLoopGroup<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>final</span> EchoServerHandler serverHandler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> EchoServerHandler<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            ServerBootstrap b <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerBootstrap<span style=color:#f92672>();</span>
            b<span style=color:#f92672>.</span><span style=color:#a6e22e>group</span><span style=color:#f92672>(</span>bossGroup<span style=color:#f92672>,</span> workerGroup<span style=color:#f92672>)</span>
             <span style=color:#f92672>.</span><span style=color:#a6e22e>channel</span><span style=color:#f92672>(</span>NioServerSocketChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
             <span style=color:#f92672>.</span><span style=color:#a6e22e>option</span><span style=color:#f92672>(</span>ChannelOption<span style=color:#f92672>.</span><span style=color:#a6e22e>SO_BACKLOG</span><span style=color:#f92672>,</span> 100<span style=color:#f92672>)</span>
             <span style=color:#f92672>.</span><span style=color:#a6e22e>handler</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> LoggingHandler<span style=color:#f92672>(</span>LogLevel<span style=color:#f92672>.</span><span style=color:#a6e22e>INFO</span><span style=color:#f92672>))</span>
             <span style=color:#f92672>.</span><span style=color:#a6e22e>childHandler</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ChannelInitializer<span style=color:#f92672>&lt;</span>SocketChannel<span style=color:#f92672>&gt;()</span> <span style=color:#f92672>{</span>
                 <span style=color:#a6e22e>@Override</span>
                 <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initChannel</span><span style=color:#f92672>(</span>SocketChannel ch<span style=color:#f92672>)</span>  <span style=color:#f92672>{</span>
                     ChannelPipeline p <span style=color:#f92672>=</span> ch<span style=color:#f92672>.</span><span style=color:#a6e22e>pipeline</span><span style=color:#f92672>();</span>
                     <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>sslCtx <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                         p<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span>sslCtx<span style=color:#f92672>.</span><span style=color:#a6e22e>newHandler</span><span style=color:#f92672>(</span>ch<span style=color:#f92672>.</span><span style=color:#a6e22e>alloc</span><span style=color:#f92672>()));</span>
                     <span style=color:#f92672>}</span>
                     <span style=color:#75715e>//p.addLast(new LoggingHandler(LogLevel.INFO));
</span><span style=color:#75715e></span>                     p<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span>serverHandler<span style=color:#f92672>);</span>
                 <span style=color:#f92672>}</span>
             <span style=color:#f92672>});</span>

            <span style=color:#75715e>// Start the server.
</span><span style=color:#75715e></span>            ChannelFuture f <span style=color:#f92672>=</span> b<span style=color:#f92672>.</span><span style=color:#a6e22e>bind</span><span style=color:#f92672>(</span>PORT<span style=color:#f92672>).</span><span style=color:#a6e22e>sync</span><span style=color:#f92672>();</span>

            <span style=color:#75715e>// Wait until the server socket is closed.
</span><span style=color:#75715e></span>            f<span style=color:#f92672>.</span><span style=color:#a6e22e>channel</span><span style=color:#f92672>().</span><span style=color:#a6e22e>closeFuture</span><span style=color:#f92672>().</span><span style=color:#a6e22e>sync</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>// Shut down all event loops to terminate all threads.
</span><span style=color:#75715e></span>            bossGroup<span style=color:#f92672>.</span><span style=color:#a6e22e>shutdownGracefully</span><span style=color:#f92672>();</span>
            workerGroup<span style=color:#f92672>.</span><span style=color:#a6e22e>shutdownGracefully</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>忽略掉ssl部分，首先构建了两个EventLoopGroup实例，在这过程中发生了什么前面已经说过了，然后是设置channel和handler以及childHandler，最终调用bind()，下面会解释netty内部都做了些什么。</p><h4 id=abstractbootstrap>AbstractBootstrap<a hidden class=anchor aria-hidden=true href=#abstractbootstrap>#</a></h4><p>上面的例子执行bind()方法后，最后进入到AbstractBootstrap.doBind()方法中</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> ChannelFuture <span style=color:#a6e22e>doBind</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> SocketAddress localAddress<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>final</span> ChannelFuture regFuture <span style=color:#f92672>=</span> initAndRegister<span style=color:#f92672>();</span>
    <span style=color:#66d9ef>final</span> Channel channel <span style=color:#f92672>=</span> regFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>channel</span><span style=color:#f92672>();</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>regFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>cause</span><span style=color:#f92672>()</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> regFuture<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>//忽略掉一些细节，最主要的就是执行下面的一段代码
</span><span style=color:#75715e></span>    ChannelPromise promise <span style=color:#f92672>=</span> channel<span style=color:#f92672>.</span><span style=color:#a6e22e>newPromise</span><span style=color:#f92672>();</span>
    doBind0<span style=color:#f92672>(</span>regFuture<span style=color:#f92672>,</span> channel<span style=color:#f92672>,</span> localAddress<span style=color:#f92672>,</span> promise<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>return</span> promise<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>


</code></pre></div><h4 id=initandregister>initAndRegister<a hidden class=anchor aria-hidden=true href=#initandregister>#</a></h4><p>initAndRegister()负责创建和初始化channel，并返回ChannelFuture对象用于后续添加监听器来异步的处理后续的任务。
initAndRegister是初始化流程中非常重要的一步，channel的构建，注册, eventLoop线程启动都是在这之中，下面会依次注明netty是如何初始化这几个对象，一些重要的说明会在代码中注释</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>final</span> ChannelFuture <span style=color:#a6e22e>initAndRegister</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    Channel channel <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>//构造netty的channel实例，也是这个时候和java nio中的原生channel做绑定
</span><span style=color:#75715e></span>        channel <span style=color:#f92672>=</span> channelFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>newChannel</span><span style=color:#f92672>();</span>
        <span style=color:#75715e>//初始化channel，server端和客户端的初始逻辑不同，server端会为pipelinee额外添加名为ServerBootstrapAcceptor的handler，而客户端只会添加初始化时用户指定的handler
</span><span style=color:#75715e></span>        init<span style=color:#f92672>(</span>channel<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>channel <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>// channel can be null if newChannel crashed (eg SocketException(&#34;too many open files&#34;))
</span><span style=color:#75715e></span>            channel<span style=color:#f92672>.</span><span style=color:#a6e22e>unsafe</span><span style=color:#f92672>().</span><span style=color:#a6e22e>closeForcibly</span><span style=color:#f92672>();</span>
            <span style=color:#75715e>// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> DefaultChannelPromise<span style=color:#f92672>(</span>channel<span style=color:#f92672>,</span> GlobalEventExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>INSTANCE</span><span style=color:#f92672>).</span><span style=color:#a6e22e>setFailure</span><span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>   
        <span style=color:#75715e>// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> DefaultChannelPromise<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> FailedChannel<span style=color:#f92672>(),</span> GlobalEventExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>INSTANCE</span><span style=color:#f92672>).</span><span style=color:#a6e22e>setFailure</span><span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
    <span style=color:#75715e>//为channel执行register注册逻辑，主要完成nio中channel的register操作，nio的selector在eventloop初始化时就已经创建好了
</span><span style=color:#75715e></span>    ChannelFuture regFuture <span style=color:#f92672>=</span> config<span style=color:#f92672>().</span><span style=color:#a6e22e>group</span><span style=color:#f92672>().</span><span style=color:#a6e22e>register</span><span style=color:#f92672>(</span>channel<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>regFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>cause</span><span style=color:#f92672>()</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>channel<span style=color:#f92672>.</span><span style=color:#a6e22e>isRegistered</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
            channel<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
            channel<span style=color:#f92672>.</span><span style=color:#a6e22e>unsafe</span><span style=color:#f92672>().</span><span style=color:#a6e22e>closeForcibly</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>return</span> regFuture<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>

</code></pre></div><ul><li><strong>init(channel)</strong> 初始化channel，server端和客户端的初始逻辑不同，server端会为pipeline额外添加名为ServerBootstrapAcceptor的handler，而客户端只会添加初始化时用户指定的handler.</li><li><strong>config().group().register(channel)</strong> 为channel执行register注册逻辑，主要完成nio中channel的register操作, selector在eventloop初始化时就已经创建好了。</li></ul><p>而eventloop轮询线程的启动也是在调用<strong>register()<strong>时触发的。
首先调用</strong>MultithreadEventLoopGroup.register</strong>()</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> ChannelFuture <span style=color:#a6e22e>register</span><span style=color:#f92672>(</span>Channel channel<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> next<span style=color:#f92672>().</span><span style=color:#a6e22e>register</span><span style=color:#f92672>(</span>channel<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>

</code></pre></div><p>next()就是从children中获取下一个eventloop, 获取具体的eventloop实例后首先通过SingleThreadEventLoop抽象类把channel包装成ChannelPromise(channelFuture接口的可写模式)并获取unsafe()来完成底层的register功能</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> ChannelFuture <span style=color:#a6e22e>register</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> ChannelPromise promise<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    ObjectUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>checkNotNull</span><span style=color:#f92672>(</span>promise<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;promise&#34;</span><span style=color:#f92672>);</span>
    promise<span style=color:#f92672>.</span><span style=color:#a6e22e>channel</span><span style=color:#f92672>().</span><span style=color:#a6e22e>unsafe</span><span style=color:#f92672>().</span><span style=color:#a6e22e>register</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> promise<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>return</span> promise<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>


<span style=color:#66d9ef>public</span> ChannelFuture <span style=color:#a6e22e>register</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> Channel channel<span style=color:#f92672>,</span> <span style=color:#66d9ef>final</span> ChannelPromise promise<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    ObjectUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>checkNotNull</span><span style=color:#f92672>(</span>promise<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;promise&#34;</span><span style=color:#f92672>);</span>
    ObjectUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>checkNotNull</span><span style=color:#f92672>(</span>channel<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;channel&#34;</span><span style=color:#f92672>);</span>
    channel<span style=color:#f92672>.</span><span style=color:#a6e22e>unsafe</span><span style=color:#f92672>().</span><span style=color:#a6e22e>register</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> promise<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>return</span> promise<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>最后由<strong>AbstractChannel</strong>抽象类的内部类<strong>AbstractUnsafe</strong>来完成底层的register操作</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>register</span><span style=color:#f92672>(</span>EventLoop eventLoop<span style=color:#f92672>,</span> <span style=color:#66d9ef>final</span> ChannelPromise promise<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    ObjectUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>checkNotNull</span><span style=color:#f92672>(</span>eventLoop<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;eventLoop&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#75715e>//已注册直接返回，future标记错误
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isRegistered<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
        promise<span style=color:#f92672>.</span><span style=color:#a6e22e>setFailure</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> IllegalStateException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;registered to an event loop already&#34;</span><span style=color:#f92672>));</span>
        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#75715e>//校验是否兼容
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>isCompatible<span style=color:#f92672>(</span>eventLoop<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
        promise<span style=color:#f92672>.</span><span style=color:#a6e22e>setFailure</span><span style=color:#f92672>(</span>
                <span style=color:#66d9ef>new</span> IllegalStateException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;incompatible event loop type: &#34;</span> <span style=color:#f92672>+</span> eventLoop<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>()));</span>
        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#75715e>//为channel绑定eventLoop
</span><span style=color:#75715e></span>    AbstractChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>eventLoop</span> <span style=color:#f92672>=</span> eventLoop<span style=color:#f92672>;</span>
    <span style=color:#75715e>//检查当前线程是否为ecentLoo绑定线程，绑定线程是在启动ecentloop时设置的
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>eventLoop<span style=color:#f92672>.</span><span style=color:#a6e22e>inEventLoop</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>//调用实际绑定方法
</span><span style=color:#75715e></span>        register0<span style=color:#f92672>(</span>promise<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>//调用execure来执行refister0()实际注册逻辑
</span><span style=color:#75715e></span>            eventLoop<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                <span style=color:#a6e22e>@Override</span>
                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                    register0<span style=color:#f92672>(</span>promise<span style=color:#f92672>);</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>});</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            logger<span style=color:#f92672>.</span><span style=color:#a6e22e>warn</span><span style=color:#f92672>(</span>
                    <span style=color:#e6db74>&#34;Force-closing a channel whose registration task was not accepted by an event loop: {}&#34;</span><span style=color:#f92672>,</span>
                    AbstractChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>this</span><span style=color:#f92672>,</span> t<span style=color:#f92672>);</span>
            closeForcibly<span style=color:#f92672>();</span>
            closeFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>setClosed</span><span style=color:#f92672>();</span>
            safeSetFailure<span style=color:#f92672>(</span>promise<span style=color:#f92672>,</span> t<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

</code></pre></div><p>经过一些校验后，通过register0()中的**doRegister()**来完成实际注册操作</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>register0</span><span style=color:#f92672>(</span>ChannelPromise promise<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>// check if the channel is still open as it could be closed in the mean time when the register
</span><span style=color:#75715e></span>        <span style=color:#75715e>// call was outside of the eventLoop
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>promise<span style=color:#f92672>.</span><span style=color:#a6e22e>setUncancellable</span><span style=color:#f92672>()</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>ensureOpen<span style=color:#f92672>(</span>promise<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>boolean</span> firstRegistration <span style=color:#f92672>=</span> neverRegistered<span style=color:#f92672>;</span>
        doRegister<span style=color:#f92672>();</span><span style=color:#75715e>//完成channel的注册
</span><span style=color:#75715e></span>        neverRegistered <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
        registered <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span><span style=color:#75715e>//标记为已注册
</span><span style=color:#75715e></span>        
        <span style=color:#f92672>...</span> pipeline部分逻辑省略
<span style=color:#f92672>}</span>
</code></pre></div><p>doRegister()的实现则在AbstractNioChannel抽象类中</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doRegister</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
<span style=color:#66d9ef>boolean</span> selected <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
<span style=color:#66d9ef>for</span> <span style=color:#f92672>(;;)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        selectionKey <span style=color:#f92672>=</span> javaChannel<span style=color:#f92672>().</span><span style=color:#a6e22e>register</span><span style=color:#f92672>(</span>eventLoop<span style=color:#f92672>().</span><span style=color:#a6e22e>unwrappedSelector</span><span style=color:#f92672>(),</span> 0<span style=color:#f92672>,</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>CancelledKeyException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#f92672>...</span>
<span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>到这里netty才完成实际的java NioChannel的注册逻辑。</p><h3 id=eventloop线程>EventLoop线程<a hidden class=anchor aria-hidden=true href=#eventloop线程>#</a></h3><p>上面讲到了如何为channel实现register绑定操作，那么回到正题EventLoop的轮询调度线程是何时被启动的呢？其实就是在刚才AbstractChannel调用register时启动的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>register</span><span style=color:#f92672>(</span>EventLoop eventLoop<span style=color:#f92672>,</span> <span style=color:#66d9ef>final</span> ChannelPromise promise<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#f92672>...</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>eventLoop<span style=color:#f92672>.</span><span style=color:#a6e22e>inEventLoop</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
        register0<span style=color:#f92672>(</span>promise<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            eventLoop<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                <span style=color:#a6e22e>@Override</span>
                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                    register0<span style=color:#f92672>(</span>promise<span style=color:#f92672>);</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>});</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#f92672>...</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

</code></pre></div><p>register会调用eventLoop的execute方法来执行register0，现在来看一下execute做了些什么。首先会进入到<strong>SingleThreadEventExecutor.execute</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span>Runnable task<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> immediate<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>//inEventLoop判断当前线程是否与SingleThreadEventExecutor.thread相同，thread是在启动loop线程时设置的，所以为启动前为null
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>boolean</span> inEventLoop <span style=color:#f92672>=</span> inEventLoop<span style=color:#f92672>();</span>
    <span style=color:#75715e>//添加任务至队列
</span><span style=color:#75715e></span>    addTask<span style=color:#f92672>(</span>task<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>inEventLoop<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>//启动eventLoop线程
</span><span style=color:#75715e></span>        startThread<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isShutdown<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>boolean</span> reject <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>removeTask<span style=color:#f92672>(</span>task<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
                    reject <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>UnsupportedOperationException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>1
            <span style=color:#f92672>}</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>reject<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                reject<span style=color:#f92672>();</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>addTaskWakesUp <span style=color:#f92672>&amp;&amp;</span> immediate<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        wakeup<span style=color:#f92672>(</span>inEventLoop<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>inEventLoop判断当前线程是否与<strong>SingleThreadEventExecutor.thread</strong>相同，thread是在启动loop线程时设置的，所以未启动前为null。</p><p><strong>SingleThreadEventExecutor</strong>先将要执行的任务添加至队列，上文提到的register任务也会添加至该队列，队列初始则是由上文提到的<strong>NioEventLoop</strong>构造器来完成的。</p><p>startThread方法主要是对状态字段state作CAS检查并执行doStartThread()</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>startThread</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>state <span style=color:#f92672>==</span> ST_NOT_STARTED<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>STATE_UPDATER<span style=color:#f92672>.</span><span style=color:#a6e22e>compareAndSet</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> ST_NOT_STARTED<span style=color:#f92672>,</span> ST_STARTED<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>boolean</span> success <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                doStartThread<span style=color:#f92672>();</span>
                success <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>success<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    STATE_UPDATER<span style=color:#f92672>.</span><span style=color:#a6e22e>compareAndSet</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> ST_STARTED<span style=color:#f92672>,</span> ST_NOT_STARTED<span style=color:#f92672>);</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

</code></pre></div><p>doStartThread通过executor来执行真正负责轮询逻辑的**SingleThreadEventExecutor.this.run()**方法, 另外executor可以通过NioEventLoopGroup构造器指定, 默认使用ThreadPerTaskExecutor每一次执行任务创建一个新线程执行任务。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doStartThread</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>assert</span> thread <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    executor<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#a6e22e>@Override</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            thread <span style=color:#f92672>=</span> Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>();</span>
            <span style=color:#75715e>//检查是否中断
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>interrupted<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                thread<span style=color:#f92672>.</span><span style=color:#a6e22e>interrupt</span><span style=color:#f92672>();</span>
            <span style=color:#f92672>}</span>
            <span style=color:#66d9ef>boolean</span> success <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
            <span style=color:#75715e>//更新时间单位为纳秒
</span><span style=color:#75715e></span>            updateLastExecutionTime<span style=color:#f92672>();</span>
            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>//执行具体的轮询任务，该方法为抽象方法
</span><span style=color:#75715e></span>                SingleThreadEventExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>run</span><span style=color:#f92672>();</span>
                success <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                logger<span style=color:#f92672>.</span><span style=color:#a6e22e>warn</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Unexpected exception from an event executor: &#34;</span><span style=color:#f92672>,</span> t<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>//省略掉了shutdown后续确认逻辑，感兴趣的可以看一下源码
</span><span style=color:#75715e></span>            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>});</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>SingleThreadEventExecutor.this.run()是抽象方法，而在netty中
实现类默认为<strong>NioEventLoop</strong>（NioEventLoop由<strong>NioEventLoopGroup</strong>确定，支持epoll的linux中用户也可以通过指定<strong>EpollEventLoopGroup</strong>来获取EpollEventLoop，java nio其实已经支持epoll操作，不过相比nio来说EpollEventLoop性能更好些，因为采用ET模式，同时更少的gc, 因为执行run的大致逻辑相同，这里就基于常用的NioEventLoop来说明）</p><p>run主要执行以下步骤：</p><ol><li>检查当前是否有任务，如果有通过supplier非阻塞调用select获取事件个数(selectNow方法，即select超时时间设置0)，否则返回<strong>SelectStrategy.SELECT</strong>枚举表示进行阻塞select</li><li>获取scheduleTask定时任务堆顶任务的deadline时间，如果枚举为SELECT则先通过deadline计算timeout并select阻塞。</li><li>获取ioRatio参数，该值决定一次轮询处理任务的 <strong>预计最大时间 = io等待时间 * （100 - ratio）/ratio</strong>，假设ratio为50则处理任务最大耗时为io时间相同，默认设置为50.</li><li>调用processSelectedKeys处理selectKeys，通过ioRatio获得处理任务最大时间并执行任务。</li></ol><p>下面是源码附注释：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>//计数器记录select次数
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> selectCnt <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(;;)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>int</span> strategy<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span><span style=color:#75715e>//当前有任务通过supplier非阻塞调用select获取事件个数，否则返回SelectStrategy.SELECT枚举表示进行阻塞select
</span><span style=color:#75715e></span>                strategy <span style=color:#f92672>=</span> selectStrategy<span style=color:#f92672>.</span><span style=color:#a6e22e>calculateStrategy</span><span style=color:#f92672>(</span>selectNowSupplier<span style=color:#f92672>,</span> hasTasks<span style=color:#f92672>());</span>
                <span style=color:#66d9ef>switch</span> <span style=color:#f92672>(</span>strategy<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>case</span> SelectStrategy<span style=color:#f92672>.</span><span style=color:#a6e22e>CONTINUE</span><span style=color:#f92672>:</span>
                    <span style=color:#66d9ef>continue</span><span style=color:#f92672>;</span>

                <span style=color:#66d9ef>case</span> SelectStrategy<span style=color:#f92672>.</span><span style=color:#a6e22e>BUSY_WAIT</span><span style=color:#f92672>:</span>
                    <span style=color:#75715e>// fall-through to SELECT since the busy-wait is not supported with NIO
</span><span style=color:#75715e></span>
                <span style=color:#66d9ef>case</span> SelectStrategy<span style=color:#f92672>.</span><span style=color:#a6e22e>SELECT</span><span style=color:#f92672>:</span>
                    <span style=color:#75715e>//获取schedule定时任务的deadline
</span><span style=color:#75715e></span>                    <span style=color:#66d9ef>long</span> curDeadlineNanos <span style=color:#f92672>=</span> nextScheduledTaskDeadlineNanos<span style=color:#f92672>();</span>
                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>curDeadlineNanos <span style=color:#f92672>==</span> <span style=color:#f92672>-</span>1L<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                        curDeadlineNanos <span style=color:#f92672>=</span> NONE<span style=color:#f92672>;</span> <span style=color:#75715e>// nothing on the calendar
</span><span style=color:#75715e></span>                    <span style=color:#f92672>}</span>
                    nextWakeupNanos<span style=color:#f92672>.</span><span style=color:#a6e22e>set</span><span style=color:#f92672>(</span>curDeadlineNanos<span style=color:#f92672>);</span>
                    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>hasTasks<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                            strategy <span style=color:#f92672>=</span> select<span style=color:#f92672>(</span>curDeadlineNanos<span style=color:#f92672>);</span>
                        <span style=color:#f92672>}</span>
                    <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
                        <span style=color:#75715e>// This update is just to help block unnecessary selector wakeups
</span><span style=color:#75715e></span>                        <span style=color:#75715e>// so use of lazySet is ok (no race condition)
</span><span style=color:#75715e></span>                        nextWakeupNanos<span style=color:#f92672>.</span><span style=color:#a6e22e>lazySet</span><span style=color:#f92672>(</span>AWAKE<span style=color:#f92672>);</span>
                    <span style=color:#f92672>}</span>
                    <span style=color:#75715e>// fall through
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IOException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// If we receive an IOException here its because the Selector is messed up. Let&#39;s rebuild
</span><span style=color:#75715e></span>                <span style=color:#75715e>// the selector and retry. https://github.com/netty/netty/issues/8566
</span><span style=color:#75715e></span>                rebuildSelector0<span style=color:#f92672>();</span>
                selectCnt <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
                handleLoopException<span style=color:#f92672>(</span>e<span style=color:#f92672>);</span>
                <span style=color:#66d9ef>continue</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>

            selectCnt<span style=color:#f92672>++;</span>
            cancelledKeys <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
            needsToSelectAgain <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
            <span style=color:#75715e>//ioRatio默认为50
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> ioRatio <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ioRatio</span><span style=color:#f92672>;</span>
            <span style=color:#66d9ef>boolean</span> ranTasks<span style=color:#f92672>;</span>
            <span style=color:#75715e>//100一次性执行全部任务
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ioRatio <span style=color:#f92672>==</span> 100<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>strategy <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                        processSelectedKeys<span style=color:#f92672>();</span>
                    <span style=color:#f92672>}</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
                    <span style=color:#75715e>// Ensure we always run tasks.
</span><span style=color:#75715e></span>                    ranTasks <span style=color:#f92672>=</span> runAllTasks<span style=color:#f92672>();</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>strategy <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> ioStartTime <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                    <span style=color:#75715e>//处理selectKey
</span><span style=color:#75715e></span>                    processSelectedKeys<span style=color:#f92672>();</span>
                <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
                    <span style=color:#75715e>// Ensure we always run tasks. 
</span><span style=color:#75715e></span>                    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> ioTime <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>()</span> <span style=color:#f92672>-</span> ioStartTime<span style=color:#f92672>;</span>
                    <span style=color:#75715e>//根据ioRatio设置任务的处理时间
</span><span style=color:#75715e></span>                    ranTasks <span style=color:#f92672>=</span> runAllTasks<span style=color:#f92672>(</span>ioTime <span style=color:#f92672>*</span> <span style=color:#f92672>(</span>100 <span style=color:#f92672>-</span> ioRatio<span style=color:#f92672>)</span> <span style=color:#f92672>/</span> ioRatio<span style=color:#f92672>);</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
                ranTasks <span style=color:#f92672>=</span> runAllTasks<span style=color:#f92672>(</span>0<span style=color:#f92672>);</span> <span style=color:#75715e>// This will run the minimum number of tasks
</span><span style=color:#75715e></span>            <span style=color:#f92672>}</span>

            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ranTasks <span style=color:#f92672>||</span> strategy <span style=color:#f92672>&gt;</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>selectCnt <span style=color:#f92672>&gt;</span> MIN_PREMATURE_SELECTOR_RETURNS <span style=color:#f92672>&amp;&amp;</span> logger<span style=color:#f92672>.</span><span style=color:#a6e22e>isDebugEnabled</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                    logger<span style=color:#f92672>.</span><span style=color:#a6e22e>debug</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Selector.select() returned prematurely {} times in a row for Selector {}.&#34;</span><span style=color:#f92672>,</span>
                            selectCnt <span style=color:#f92672>-</span> 1<span style=color:#f92672>,</span> selector<span style=color:#f92672>);</span>
                <span style=color:#f92672>}</span>
                selectCnt <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>unexpectedSelectorWakeup<span style=color:#f92672>(</span>selectCnt<span style=color:#f92672>))</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// Unexpected wakeup (unusual case)
</span><span style=color:#75715e></span>                selectCnt <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>CancelledKeyException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>// Harmless exception - log anyway
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>logger<span style=color:#f92672>.</span><span style=color:#a6e22e>isDebugEnabled</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                logger<span style=color:#f92672>.</span><span style=color:#a6e22e>debug</span><span style=color:#f92672>(</span>CancelledKeyException<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getSimpleName</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; raised by a Selector {} - JDK bug?&#34;</span><span style=color:#f92672>,</span>
                        selector<span style=color:#f92672>,</span> e<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            handleLoopException<span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>
        <span style=color:#75715e>// Always handle shutdown even if the loop processing threw an exception.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isShuttingDown<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                closeAll<span style=color:#f92672>();</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>confirmShutdown<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                    <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            handleLoopException<span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

</code></pre></div><p>关于轮询逻辑还有两个比较重要的点：</p><ul><li>这里处理任务最大时间是预估时间，原理是串行处理任务时刷新并比对deadline时间，可想而知如果任务是阻塞的就会严重影响nioEventLoop的性能，因此要求用户不要执行阻塞的任务。</li><li>细心的可能注意到有一个计数变量selectCnt用来表示select次数，在末尾处会调用unexpectedSelectorWakeup方法校验selectCnt数值是否超出阈值（默认512),如果超出阈值则调用rebuildSelector重新创建新的selector，并把旧的selector已注册的channel重新加入到新的selector中.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>unexpectedSelectorWakeup</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> selectCnt<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#f92672>...</span><span style=color:#a6e22e>省略部分代码</span>

    <span style=color:#75715e>//检查selectCnt是否超出阈值，如果超出阈值则调用rebuildSelector重新创建新的selector，并把旧的selector已注册的channel重新加入到新的selector中
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>SELECTOR_AUTO_REBUILD_THRESHOLD <span style=color:#f92672>&gt;</span> 0 <span style=color:#f92672>&amp;&amp;</span>
            selectCnt <span style=color:#f92672>&gt;=</span> SELECTOR_AUTO_REBUILD_THRESHOLD<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>// The selector returned prematurely many times in a row.
</span><span style=color:#75715e></span>        <span style=color:#75715e>// Rebuild the selector to work around the problem.
</span><span style=color:#75715e></span>        logger<span style=color:#f92672>.</span><span style=color:#a6e22e>warn</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Selector.select() returned prematurely {} times in a row; rebuilding Selector {}.&#34;</span><span style=color:#f92672>,</span>
                selectCnt<span style=color:#f92672>,</span> selector<span style=color:#f92672>);</span>
        rebuildSelector<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>

</code></pre></div><p>为什么超出阈值就要重新构造selector呢，这来源于jdk nio一个有名的epoll cpu 100%的bug，<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6403933">jdk-bug-6403933</a>，该bug使select不能正常阻塞，因用户nio线程空转导致cpu飙升，所以netty使用计数的方式来检测该问题，并重新构建selector。</p><h3 id=workerboss的分工>worker、boss的分工<a hidden class=anchor aria-hidden=true href=#workerboss的分工>#</a></h3><p>BootStrap初始化的时候会要求设置worker和boss，例如EchoServer例子中的bossGroup和workerGroup，一般介绍中都会说到boss负责accpet，worker负责IO事件如下图，下面来解析netty如何调度流转worker和boss
<img src=/img/bVcKydh alt=image.png></p><p>首先Java NIO server需要指定ServerSocketChannel来完成bind、accept等操作，而netty则是对NIO的封装，那么ServerSocketChannel是在何时构造的呢，是在调用<strong>initAndRegister</strong>是，initAndRegister时会调用channelFactory.newChannel()</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>final</span> ChannelFuture <span style=color:#a6e22e>initAndRegister</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    Channel channel <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        channel <span style=color:#f92672>=</span> channelFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>newChannel</span><span style=color:#f92672>();</span>
        init<span style=color:#f92672>(</span>channel<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
    <span style=color:#f92672>....</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>channelFactory需要指定class来实例化channel，这个channel即使在构造BootStrap时声明的，如下实例声明的NioServerSocketChannel.class</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>ServerBootstrap b <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerBootstrap<span style=color:#f92672>();</span>
b<span style=color:#f92672>.</span><span style=color:#a6e22e>group</span><span style=color:#f92672>(</span>bossGroup<span style=color:#f92672>,</span> workerGroup<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>channel</span><span style=color:#f92672>(</span>NioServerSocketChannel<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>option</span><span style=color:#f92672>(</span>ChannelOption<span style=color:#f92672>.</span><span style=color:#a6e22e>SO_BACKLOG</span><span style=color:#f92672>,</span> 100<span style=color:#f92672>)</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>handler</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> LoggingHandler<span style=color:#f92672>(</span>LogLevel<span style=color:#f92672>.</span><span style=color:#a6e22e>INFO</span><span style=color:#f92672>))</span>
</code></pre></div><p>之后就执行BossGroup下的EventLoop轮询逻辑，到目前为止其实与Worker还没有关系，先看一下如果用户声明的是ServerBootstrap，那么在调用initAndRegester时会调用init()，init又一个重要操作就是通过匿名函数将<strong>ServerBootstrapAcceptor</strong>加入到链表尾部。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span><span style=color:#f92672>(</span>Channel channel<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>//设置参数
</span><span style=color:#75715e></span>    setChannelOptions<span style=color:#f92672>(</span>channel<span style=color:#f92672>,</span> newOptionsArray<span style=color:#f92672>(),</span> logger<span style=color:#f92672>);</span>
    setAttributes<span style=color:#f92672>(</span>channel<span style=color:#f92672>,</span> attrs0<span style=color:#f92672>().</span><span style=color:#a6e22e>entrySet</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toArray</span><span style=color:#f92672>(</span>EMPTY_ATTRIBUTE_ARRAY<span style=color:#f92672>));</span>
    <span style=color:#75715e>//获取pipelone
</span><span style=color:#75715e></span>    ChannelPipeline p <span style=color:#f92672>=</span> channel<span style=color:#f92672>.</span><span style=color:#a6e22e>pipeline</span><span style=color:#f92672>();</span>

    <span style=color:#66d9ef>final</span> EventLoopGroup currentChildGroup <span style=color:#f92672>=</span> childGroup<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>final</span> ChannelHandler currentChildHandler <span style=color:#f92672>=</span> childHandler<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>final</span> Entry<span style=color:#f92672>&lt;</span>ChannelOption<span style=color:#f92672>&lt;?&gt;,</span> Object<span style=color:#f92672>&gt;[]</span> currentChildOptions<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>childOptions<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        currentChildOptions <span style=color:#f92672>=</span> childOptions<span style=color:#f92672>.</span><span style=color:#a6e22e>entrySet</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toArray</span><span style=color:#f92672>(</span>EMPTY_OPTION_ARRAY<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>final</span> Entry<span style=color:#f92672>&lt;</span>AttributeKey<span style=color:#f92672>&lt;?&gt;,</span> Object<span style=color:#f92672>&gt;[]</span> currentChildAttrs <span style=color:#f92672>=</span> childAttrs<span style=color:#f92672>.</span><span style=color:#a6e22e>entrySet</span><span style=color:#f92672>().</span><span style=color:#a6e22e>toArray</span><span style=color:#f92672>(</span>EMPTY_ATTRIBUTE_ARRAY<span style=color:#f92672>);</span>
    <span style=color:#75715e>//将handler添加至尾部
</span><span style=color:#75715e></span>    p<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ChannelInitializer<span style=color:#f92672>&lt;</span>Channel<span style=color:#f92672>&gt;()</span> <span style=color:#f92672>{</span>
        <span style=color:#a6e22e>@Override</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initChannel</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> Channel ch<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>final</span> ChannelPipeline pipeline <span style=color:#f92672>=</span> ch<span style=color:#f92672>.</span><span style=color:#a6e22e>pipeline</span><span style=color:#f92672>();</span>
            ChannelHandler handler <span style=color:#f92672>=</span> config<span style=color:#f92672>.</span><span style=color:#a6e22e>handler</span><span style=color:#f92672>();</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>handler <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                pipeline<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span>handler<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>

            ch<span style=color:#f92672>.</span><span style=color:#a6e22e>eventLoop</span><span style=color:#f92672>().</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                <span style=color:#a6e22e>@Override</span>
                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                    pipeline<span style=color:#f92672>.</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ServerBootstrapAcceptor<span style=color:#f92672>(</span>
                            ch<span style=color:#f92672>,</span> currentChildGroup<span style=color:#f92672>,</span> currentChildHandler<span style=color:#f92672>,</span> currentChildOptions<span style=color:#f92672>,</span> currentChildAttrs<span style=color:#f92672>));</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>});</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>});</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>ServerBootstrapAcceptor是InboundHandler类型，会把BossGroup下的Eventloop监听到的Channel事件注册到childGroup(即worker)下，代码如下</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>channelRead</span><span style=color:#f92672>(</span>ChannelHandlerContext ctx<span style=color:#f92672>,</span> Object msg<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>final</span> Channel child <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Channel<span style=color:#f92672>)</span> msg<span style=color:#f92672>;</span>
    <span style=color:#75715e>//将childHandler加入链表
</span><span style=color:#75715e></span>    child<span style=color:#f92672>.</span><span style=color:#a6e22e>pipeline</span><span style=color:#f92672>().</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span>childHandler<span style=color:#f92672>);</span>

    setChannelOptions<span style=color:#f92672>(</span>child<span style=color:#f92672>,</span> childOptions<span style=color:#f92672>,</span> logger<span style=color:#f92672>);</span>
    setAttributes<span style=color:#f92672>(</span>child<span style=color:#f92672>,</span> childAttrs<span style=color:#f92672>);</span>

    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>//将channel注册至childGroup，即workerGroup下
</span><span style=color:#75715e></span>        childGroup<span style=color:#f92672>.</span><span style=color:#a6e22e>register</span><span style=color:#f92672>(</span>child<span style=color:#f92672>).</span><span style=color:#a6e22e>addListener</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ChannelFutureListener<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            <span style=color:#a6e22e>@Override</span>
            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operationComplete</span><span style=color:#f92672>(</span>ChannelFuture future<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>future<span style=color:#f92672>.</span><span style=color:#a6e22e>isSuccess</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
                    forceClose<span style=color:#f92672>(</span>child<span style=color:#f92672>,</span> future<span style=color:#f92672>.</span><span style=color:#a6e22e>cause</span><span style=color:#f92672>());</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>});</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>//出现异常关闭channel
</span><span style=color:#75715e></span>        forceClose<span style=color:#f92672>(</span>child<span style=color:#f92672>,</span> t<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

</code></pre></div><p>到此就完成了boss和worker之间的流转，至于channel是如何流转，pipeline原理等其他内容就放到Channel篇来讲述。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cyberword.github.io/tags/java>JAVA</a></li><li><a href=https://cyberword.github.io/tags/netty>Netty</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2020 <a href=https://cyberword.github.io/>A Coder</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=https://cyberword.github.io/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>